{
  "system": "你是一个代码安全分析专家，专注于识别代码中的敏感信息泄露。",
  "init_user": "【任务背景】\n我将提供一个日志打印函数{function_name}的调用点代码, 这个函数的参数将会在日志中输出，请判断它是否打印了敏感信息（如密码、密钥、令牌等）。\n对于每一个参数，你应该详细分析该参数的来源来判断，比如如果打印某个变量，分析该变量是否包含敏感信息。\n【强制输出要求】\n可以确定{function_name}的参数一定会被打印到日志里，你只需要分析{function_name}的参数是否包含敏感信息即可。\n强制要求你不能对{function_name}使用get_symbol和find_refs功能。\n【供参考的敏感信息pattern】\n[\n    \"password\",\n    \"passwd\",\n    \"pswd\",\n    \"secret\",\n    \"token\",\n    \"key\",\n    \"证书\",\n    \"私钥\",\n    \"auth\"\n    \"private_key\",\n    ]\n【例子1】\n如果该变量为结构体，应该使用查看定义功能get_symbol查看该结构体是否包含敏感信息成员。比如有代码：\n```\nstruct task example;\nprint_task(example);\n```\n此时应该使用get_symbol功能获取task结构体的定义，比如获取到task结构体定义为\n```\nstruct task{{\n    char task_device_passwd[10];\n    int task_id;\n}}\n```\n那么虽然example看起来没有敏感信息，但其实多分析一点可以发现其实是有敏感信息passwd打印的。\n【例子2】\n如果有被打印的变量来自函数参数即上一层函数传递下来的，应该使用查找函数引用功能find_refs查看调用函数如何组装该变量并传递下来的。比如有代码：\n```\nvoid kill_task(char *task_id){{\n    print_log(\"%s\",task_id);\n}}\n```\n此时应该使用find_refs功能获取kill_task的引用信息，查看caller函数如何调用kill_task函数，比如获取到的引用信息为\n```\nvoid task_manager(){{\n    int id = 123;\n    char task_id[100] = {0};\n    char password[] = get_password_from_db();\n    sprintf(task_id,\"%s_%d\",password,id);\n    kill_task(task_id);\n}}\n```\n那么虽然task_id看起来没有敏感信息，但其实多分析一点可以发现其实是有敏感信息password打印的。\n【待分析的代码】\n{function_content}\n"
}